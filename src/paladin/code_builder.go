package paladin

import (
	"fmt"
	"frm/plog"
	"reflect"

	"cmn"

	"github.com/dave/jennifer/jen"
)

type CodeBuilder struct {
	jfile      *jen.File
	codeDir    string
	dataDir    string
	fileName   string
	structName string // 给定的外层结构名, 为解决创建的匿名结构问题
}

func NewCodeBuilder(codeDir string, dataDir string, fileName string) *CodeBuilder {
	c := new(CodeBuilder)
	c.codeDir = codeDir
	c.dataDir = dataDir
	c.fileName = fileName
	c.jfile = jen.NewFile("dbc")
	c.jfile.HeaderComment("// Code generated by paladin. DO NOT EDIT.")
	return c
}

func (p *CodeBuilder) GenStruct(obj interface{}) {
	p.structName = reflect.TypeOf(obj).Name()
	p.GenStructWithName(obj, p.structName)
}

func (p *CodeBuilder) GenStructWithName(obj interface{}, structName string) {
	p.structName = cmn.CamelName(structName)
	t := reflect.TypeOf(obj)
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	p.genType(t, p.structName, "")
	p.genValue()
	p.genGet()
	p.genGetAll()
	p.genInit()
}

func (p *CodeBuilder) GenType(t reflect.Type, structName string) {
	p.structName = structName
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	p.genType(t, p.structName, "")
	p.genValue()
	p.genGet()
	p.genGetAll()
	p.genInit()
}

func (p *CodeBuilder) genType(t reflect.Type, structName string, printPrefix string) {
	//fmt.Printf("%s[gen type %s]\n", printPrefix, t.Name())
	fields := make([]jen.Code, t.NumField())
	for i := 0; i < t.NumField(); i++ {
		subField := t.Field(i)
		//fmt.Printf("%sfield %d %s %s\n", printPrefix+"  ", i, t.Field(i).Name, t.Field(i).Type.Kind().String())
		switch subField.Type.Kind() {
		case reflect.Struct:
			subStruct := structName + subField.Name
			p.genType(subField.Type, subStruct, printPrefix+"  ")
			fields[i] = jen.Id(subField.Name).Id(subStruct)

		case reflect.Map:
			mapSubStruct := structName + subField.Name + "Elem"
			p.genType(subField.Type.Elem(), mapSubStruct, printPrefix+"  ")
			fields[i] = jen.Id(subField.Name).Map(p.TypeToJenStatement(subField.Type.Key())).Id(mapSubStruct)

		case reflect.Slice:
			sliceSubStruct := structName + subField.Name + "Elem"
			p.genType(subField.Type.Elem(), sliceSubStruct, printPrefix+"  ")
			fields[i] = jen.Id(subField.Name).Index().Id(sliceSubStruct)

		default:
			// 基础类型
			fields[i] = p.AppendKeyword(jen.Id(subField.Name), subField.Type)
		}
	}
	if structName == "" {
		structName = t.Name()
	}
	p.jfile.Type().Id(structName).Struct(fields...)
}

// 生成变量声明代码
func (p *CodeBuilder) genValue() {
	p.jfile.Var().Id("tbl" + p.structName).Map(jen.Int64()).Id("*" + p.structName)
}

// 生成GetXXX(id) *XXX
func (p *CodeBuilder) genGet() {
	p.jfile.Func().Id("Get" + p.structName).Params(jen.Id("id").Int64()).Id("*" + p.structName).Block(
		jen.Return().Id("tbl" + p.structName).Index(jen.Id("id")),
	)
}

// 生成GetAllXXX() []*XXX
func (p *CodeBuilder) genGetAll() {
	p.jfile.Func().Id("GetAll" + p.structName).Params().Map(jen.Int64()).Id("*" + p.structName).Block(
		jen.Return().Id("tbl" + p.structName),
	)
}

/*
	file, err := os.Open("bin/output/location.json")
	if err != nil {
		plog.Error(err)
		return
	}
	decoder := json.NewDecoder(file)
	if err = decoder.Decode(&tblLocation); err != nil {
		plog.Error(err)
	}
*/
func (p *CodeBuilder) genInit() {
	p.jfile.Func().Id("init").Params().Block(
		jen.List(jen.Id("file"), jen.Id("err")).Op(":=").Qual("os", "Open").Call(jen.Lit(p.dataDir+"/"+p.fileName+".json")),
		jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Qual("fmt", "Println").Call(jen.List(jen.Lit("fail to open!!"), jen.Id("err"))),
			jen.Return(),
		),
		jen.Id("decoder").Op(":=").Qual("json", "NewDecoder").Call(jen.Id("file")),
		jen.Id("err").Op("=").Qual("decoder", "Decode").Call(jen.Id("&tbl"+p.structName)),
		jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Qual("fmt", "Println").Call(jen.List(jen.Lit("fail to decode!!"), jen.Id("err"))),
			jen.Return(),
		),
	)
}

// 输出
func (p *CodeBuilder) Output() {
	if err := p.jfile.Save(p.codeDir + "/" + p.fileName + ".dbc.go"); err != nil {
		plog.Error(err)
	}
}

func (p *CodeBuilder) DebugType(t reflect.Type, structName string) {
	p.structName = structName
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	p.genType(t, p.structName, "")
	fmt.Printf("%#v\n", p.jfile)
}

// 反射类型转换为jennifer语句
func (p *CodeBuilder) TypeToJenStatement(t reflect.Type) *jen.Statement {
	switch t.Kind() {
	case reflect.Bool:
		return jen.Bool()

	case reflect.Int:
		return jen.Int()

	case reflect.String:
		return jen.String()

	case reflect.Float32:
		return jen.Float32()

	case reflect.Float64:
		return jen.Float64()

	default:
		return jen.String()
	}
}

func (p *CodeBuilder) AppendKeyword(code *jen.Statement, t reflect.Type) *jen.Statement {
	switch t.Kind() {
	case reflect.Bool:
		return code.Bool()

	case reflect.Float32:
		return code.Float32()

	case reflect.Float64:
		return code.Float64()

	case reflect.Int:
		return code.Int()

	case reflect.String:
		return code.String()

	default:
		plog.Panic("not support type", t)
		return nil
	}
}

func (p *CodeBuilder) structNameToValueName(structName string) (valueName string) {
	if structName == "" {
		return ""
	}
	bs := make([]byte, 0, len(structName))
	bs = append(bs, structName[0]+32)
	bs = append(bs, structName[1:]...)
	return string(bs)
}
